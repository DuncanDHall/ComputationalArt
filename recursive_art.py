""" 
This script saves things to your computer! it will generate a folder in
it's current directory with a time stamp, and generate some artwork in it,
as well as give you some deets about the back end of the generation (in the 
form of .txt files. You can specify your own rgb color values as well. The 
color palet I have at the bottom of the file right now is generated by 
color.adobe.com's triad color rule, which I have darkened. 
"""

from __future__ import division
import random
import time
import os.path
from math import sin, cos, pi, sqrt
from PIL import Image


def build_random_function(min_depth, max_depth, starting_function=[]):
    """ Builds a random function of depth at least min_depth and depth
        at most max_depth (see assignment writeup for definition of depth
        in this context)

        min_depth: the minimum depth of the random function
        max_depth: the maximum depth of the random function
        returns: the randomly generated function represented as a nested list
                 (see assignment writeup for details on the representation of
                 these functions)
    >>> seed = build_random_function(3, 3)
    >>> print seed
    >>> build_random_function(4, 4, seed)
    >>> build_random_function(6, 6, seed)
    """
    # TODO: implement this
    functions_to_operands = {'prod': 2,
                             'avg': 2,
                             'cos_pi': 1,
                             'sin_pi': 1,
                             'sqrt': 1,
                             'square': 1,
                             }

    def recurse(min_depth, max_depth, root=False):
        # return [a_function, op1, op2]
        depth = random.randint(min_depth, max_depth)
        if depth <= 1:
            if root:
                return root
            else:
                return [random.choice(['x', 'y'])]
        else:
            new_function = random.choice(functions_to_operands.keys())
            if root == ['y']:
                roots = [['y'], ['x']]
            else:
                roots = [['x'], ['y']]
            return (
                [new_function] +
                [
                    recurse(min_depth-1, max_depth-1, roots[operand])
                    for operand in range(functions_to_operands[new_function])
                ])

    def further_recurse(min_depth, max_depth, function):
        copy = function[:]
        if copy == ['x'] or copy == ['y']:
            return recurse(min_depth, max_depth, copy)
        else:
            for item in copy:
                if item == ['x'] or item == ['y']:
                    copy[copy.index(item)] = recurse(
                        min_depth, max_depth, item)
                elif isinstance(item, list):
                    copy[copy.index(item)] = further_recurse(
                        min_depth, max_depth, item)
                else:
                    pass
            return copy

    if starting_function == []:
        return recurse(min_depth, max_depth)
    else:
        return further_recurse(min_depth, max_depth, starting_function)


def evaluate_random_function(f, x, y):
    """ Evaluate the random function f with inputs x,y
        Representation of the function f is defined in the assignment writeup

        f: the function to evaluate
        x: the value of x to be used to evaluate the function
        y: the value of y to be used to evaluate the function
        returns: the function value

        >>> evaluate_random_function(["x"], -0.5, 0.75)
        -0.5
        >>> evaluate_random_function(["y"], 0.1, 0.02)
        0.02
        >>> function = ['avg', ['cos_pi', ['y']], ['sqrt', ['cos_pi', ['x']]]]
        >>> evaluate_random_function(function, 0.5, -0.5)
    """
    # TODO: implement this
    function = f[0]

    if function == 'x':
        return x
    elif function == 'y':
        return y
    elif function == 'prod':
        return (
            evaluate_random_function(f[1], x, y) *
            evaluate_random_function(f[2], x, y)
            )
    elif function == 'avg':
        return (
            evaluate_random_function(f[1], x, y) +
            evaluate_random_function(f[2], x, y)
            )
    elif function == 'cos_pi':
        return cos(pi*evaluate_random_function(f[1], x, y))
    elif function == 'sin_pi':
        return sin(pi*evaluate_random_function(f[1], x, y))
    elif function == 'sqrt':
        operand = evaluate_random_function(f[1], x, y)
        if operand >= 0:
            return sqrt(operand)
        else:
            return -sqrt(-operand)
    elif function == 'square':
        return evaluate_random_function(f[1], x, y) ** 2

    # else statement intentionally left out


def remap_interval(val,
                   input_interval_start,
                   input_interval_end,
                   output_interval_start,
                   output_interval_end):
    """ Given an input value in the interval [input_interval_start,
        input_interval_end], return an output value scaled to fall within
        the output interval [output_interval_start, output_interval_end].

        val: the value to remap
        input_interval_start: the start of the interval that contains all
                              possible values for val
        input_interval_end: the end of the interval that contains all possible
                            values for val
        output_interval_start: the start of the interval that contains all
                               possible output values
        output_inteval_end: the end of the interval that contains all possible
                            output values
        returns: the value remapped from the input to the output interval

        >>> remap_interval(0.5, 0, 1, 0, 10)
        5.0
        >>> remap_interval(5, 4, 6, 0, 2)
        1.0
        >>> remap_interval(5, 4, 6, 1, 2)
        1.5
    """
    # TODO: implement this
    prop_val = ((val - input_interval_start) /  # python3 division from future
                (input_interval_end - input_interval_start))
    return (prop_val * (output_interval_end - output_interval_start) +
            output_interval_start)


def color_map(val):
    """ Maps input value between -1 and 1 to an integer 0-255, suitable for
        use as an RGB color code.

        val: value to remap, must be a float in the interval [-1, 1]
        returns: integer in the interval [0,255]

        >>> color_map(-1.0)
        0
        >>> color_map(1.0)
        255
        >>> color_map(0.0)
        127
        >>> color_map(0.5)
        191
    """
    # NOTE: This relies on remap_interval, which you must provide
    color_code = remap_interval(val, -1, 1, 0, 255)
    return int(color_code)


def test_image(filename, x_size=350, y_size=350):
    """ Generate test image with random pixels and save as an image file.

        filename: string filename for image (should be .png)
        x_size, y_size: optional args to set image dimensions (default: 350)
    """
    # Create image and loop over all pixels
    im = Image.new("RGB", (x_size, y_size))
    pixels = im.load()
    for i in range(x_size):
        for j in range(y_size):
            x = remap_interval(i, 0, x_size, -1, 1)
            y = remap_interval(j, 0, y_size, -1, 1)
            pixels[i, j] = (random.randint(0, 255),  # Red channel
                            random.randint(0, 255),  # Green channel
                            random.randint(0, 255))  # Blue channel

    im.save(filename)


def generate_art(
        min_depth, max_depth, min_varience=-1, max_varience=-1,
        color1=[1.0, 0.0, 0.0], color2=[0.0, 1.0, 0.0], color3=[0.0, 0.0, 1.0],
        x_size=350, y_size=350,
        ):
    """ Generate computational art and save as an image file.

        filename: string filename for image (should be .png)
        x_size, y_size: optional args to set image dimensions (default: 350)
    """
    if min_varience == -1:
        min_varience = min_depth
    if max_varience == -1:
        max_varience = max_depth

    # Functions for red, green, and blue channels - where the magic happens!
    seed_function = build_random_function(min_depth, max_depth)

    # red_function = build_random_function(
    #     min_varience, max_varience, seed_function)
    # green_function = build_random_function(
    #     min_varience, max_varience, seed_function)
    # blue_function = build_random_function(
    #     min_varience, max_varience, seed_function)

    color1_function = build_random_function(
        min_varience, max_varience, seed_function)
    color2_function = build_random_function(
        min_varience, max_varience, seed_function)
    color3_function = build_random_function(
        min_varience, max_varience, seed_function)


    # Create image and loop over all pixels
    im = Image.new("RGB", (x_size, y_size))
    pixels = im.load()
    for i in range(x_size):
        for j in range(y_size):
            x = remap_interval(i, 0, x_size, -1, 1)
            y = remap_interval(j, 0, y_size, -1, 1)

            color1_value = evaluate_random_function(color1_function, x, y)
            color2_value = evaluate_random_function(color2_function, x, y)
            color3_value = evaluate_random_function(color3_function, x, y)

            red_value = min(color1_value*color1[0] +
                            color2_value*color2[0] +
                            color3_value*color3[0],
                            1.0)
            green_value = min(color1_value*color1[1] +
                              color2_value*color2[1] +
                              color3_value*color3[1],
                              1.0)
            blue_value = min(color1_value*color1[2] +
                             color2_value*color2[2] +
                             color3_value*color3[2],
                             1.0)

            pixels[i, j] = (
                    color_map(red_value),
                    color_map(green_value),
                    color_map(blue_value)
                    )

    return {
        'image': im,
        'functions': [
            seed_function, color1_function, color2_function, color3_function
            ]
        }


def generate_and_save_art(
        batch_size, depth, varience=-1,
        color1=[1.0, 0.0, 0.0], color2=[0.0, 1.0, 0.0], color3=[0.0, 0.0, 1.0],
        x_size=350, y_size=350,
        optional_tag='', name_stem='art',):
    """ Created to handle unique saving of images. Creates and saves a number of
        images from generate_art() in a folder with the current date. Also logs
        functions for each color channel in functions.txt
    """

    batch_folder_name = time.strftime('%I.%M.%S_%d.%m.%Y')
    os.mkdir(batch_folder_name)

    current_dir_stem = os.getcwd() + '/' + batch_folder_name + '/'

    for i in range(batch_size):
        file_name = name_stem + str(i+1) + '.png'
        instance = generate_art(
            depth, depth, varience, varience,
            color1, color2, color3,
            x_size, y_size)
        # save image
        image = instance['image']
        image.save(current_dir_stem + file_name)

        # log info
        functions = instance['functions']
        log = (
            file_name + '\n'
            '\t seed function: ' + str(functions[0]) + '\n' +
            '\t color 1 function: ' + str(functions[1]) + '\n' +
            '\t color 2 function: ' + str(functions[2]) + '\n' +
            '\t color 3 function: ' + str(functions[3]) + '\n' +
            '\n\n'
        )
        with open(current_dir_stem + name_stem + str(i+1) + '.txt', 'a') as f:
            f.write(log)

if __name__ == '__main__':
    # import doctest
    # # doctest.testmod()
    # doctest.run_docstring_examples(build_random_function,
    #                                globals(), verbose=True,
    #                                name="Jus' Testin'")

    generate_and_save_art(5, 3, 3,
                          [0/500, 255/500, 237/500],
                          [255/500, 207/500, 0/500],
                          [204/500, 20/500, 178/500])

    # Test that PIL is installed correctly
    # TODO: Comment or remove this function call after testing PIL install
    # test_image("noise.png")
